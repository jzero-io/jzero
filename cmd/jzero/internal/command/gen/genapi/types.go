package genapi

import (
	"fmt"
	"go/ast"
	"go/token"
	"os"
	"path/filepath"
	"strings"
	"sync"

	"github.com/rinchsan/gosimports"
	"github.com/samber/lo"
	"github.com/zeromicro/go-zero/tools/goctl/api/gogen"
	"github.com/zeromicro/go-zero/tools/goctl/api/spec"
	"github.com/zeromicro/go-zero/tools/goctl/util"
	"golang.org/x/sync/errgroup"
	"golang.org/x/tools/go/ast/astutil"

	"github.com/jzero-io/jzero/cmd/jzero/internal/pkg/templatex"
)

func (ja *JzeroApi) separateTypesGo(apiFiles []string, apiSpecMap map[string]*spec.ApiSpec) error {
	_, typesWithoutPackage, err := ja.collectAndGenerateTypesByPackage(apiFiles, apiSpecMap)
	if err != nil {
		return err
	}

	// 去重并生成默认 types.go
	if len(typesWithoutPackage) > 0 {
		if err := ja.generateDefaultTypesFile(typesWithoutPackage); err != nil {
			return err
		}
	}

	return nil
}

// apiFileTypes 表示 API 文件的类型信息
type apiFileTypes struct {
	file         string
	types        []spec.Type
	goPackage    string
	typesGoBytes []byte
}

// collectAndGenerateTypesByPackage 收集并按包生成 types.go 文件
func (ja *JzeroApi) collectAndGenerateTypesByPackage(apiFiles []string, apiSpecMap map[string]*spec.ApiSpec) (typesWithPackage []apiFileTypes, typesWithoutPackage []spec.Type, err error) {
	var eg errgroup.Group
	var mu sync.Mutex
	results := make([]apiFileTypes, 0, len(apiFiles))

	for _, apiFile := range apiFiles {
		currentFile := apiFile
		currentSpec := apiSpecMap[apiFile]

		eg.Go(func() error {
			fileTypes, err := ja.processApiFileTypes(currentFile, currentSpec)
			if err != nil {
				return err
			}

			mu.Lock()
			if fileTypes.goPackage != "" {
				results = append(results, fileTypes)
			} else {
				typesWithoutPackage = append(typesWithoutPackage, fileTypes.types...)
			}
			mu.Unlock()

			return nil
		})
	}

	if err := eg.Wait(); err != nil {
		return nil, nil, err
	}

	// 并发生成有 go_package 的 types.go 文件
	eg = errgroup.Group{}
	for _, fileTypes := range results {
		currentTypes := fileTypes
		eg.Go(func() error {
			return ja.writeTypesFile(currentTypes.goPackage, currentTypes.typesGoBytes)
		})
	}

	if err := eg.Wait(); err != nil {
		return nil, nil, err
	}

	return results, typesWithoutPackage, nil
}

// processApiFileTypes 处理单个 API 文件的类型
func (ja *JzeroApi) processApiFileTypes(apiFile string, apiSpec *spec.ApiSpec) (apiFileTypes, error) {
	typesGoString, err := gogen.BuildTypes(apiSpec.Types)
	if err != nil {
		return apiFileTypes{}, err
	}

	goPackage, hasGoPackage := apiSpec.Info.Properties["go_package"]
	if !hasGoPackage || goPackage == "" {
		return apiFileTypes{
			file:  apiFile,
			types: apiSpec.Types,
		}, nil
	}

	packageName := strings.ToLower(strings.ReplaceAll(goPackage, "/", ""))
	typesGoBytes, err := templatex.ParseTemplate("inner_types.go", map[string]any{
		"Types":   typesGoString,
		"Package": packageName,
	}, []byte(`// Code generated by jzero. DO NOT EDIT.
package {{.Package}}

import (
    "time"
)

var (
    _ = time.Now()
)

{{.Types}}`))
	if err != nil {
		return apiFileTypes{}, err
	}

	return apiFileTypes{
		file:         apiFile,
		types:        apiSpec.Types,
		goPackage:    goPackage,
		typesGoBytes: typesGoBytes,
	}, nil
}

// writeTypesFile 写入 types.go 文件
func (ja *JzeroApi) writeTypesFile(goPackage string, typesGoBytes []byte) error {
	typesDir := filepath.Join("internal", "types", goPackage)
	if err := os.MkdirAll(typesDir, 0o755); err != nil {
		return err
	}

	process, err := gosimports.Process("", typesGoBytes, nil)
	if err != nil {
		return err
	}

	return os.WriteFile(filepath.Join(typesDir, "types.go"), process, 0o644)
}

// generateDefaultTypesFile 生成默认的 types.go 文件
func (ja *JzeroApi) generateDefaultTypesFile(allTypes []spec.Type) error {
	// 去重
	uniqueTypes := ja.deduplicateTypes(allTypes)

	typesGoString, err := gogen.BuildTypes(uniqueTypes)
	if err != nil {
		return err
	}

	typesGoBytes, err := templatex.ParseTemplate("inner_types.go", map[string]any{
		"Types": typesGoString,
	}, []byte(`// Code generated by jzero. DO NOT EDIT.
package types

import (
    "time"
)

var (
    _ = time.Now()
)

{{.Types}}`))
	if err != nil {
		return err
	}

	process, err := gosimports.Process("", typesGoBytes, nil)
	if err != nil {
		return err
	}

	return os.WriteFile(filepath.Join("internal", "types", "types.go"), process, 0o644)
}

// deduplicateTypes 去重类型列表
func (ja *JzeroApi) deduplicateTypes(types []spec.Type) []spec.Type {
	var result []spec.Type
	exist := make(map[string]struct{})
	for _, t := range types {
		if _, ok := exist[t.Name()]; ok {
			continue
		}
		result = append(result, t)
		exist[t.Name()] = struct{}{}
	}
	return result
}

func (ja *JzeroApi) updateHandlerImportedTypesPath(f *ast.File, fset *token.FileSet, file HandlerFile) error {
	if astutil.UsesImport(f, fmt.Sprintf("%s/internal/types", ja.Module)) {
		astutil.DeleteImport(fset, f, fmt.Sprintf("%s/internal/types", ja.Module))
		astutil.AddNamedImport(fset, f, "types", fmt.Sprintf("%s/internal/types/%s", ja.Module, file.Package))
	}

	return nil
}

func (ja *JzeroApi) updateLogicImportedTypesPath(f *ast.File, fset *token.FileSet, file LogicFile) error {
	astutil.DeleteImport(fset, f, fmt.Sprintf("%s/internal/types", ja.Module))
	if file.RequestType == nil && file.ResponseType == nil {
		return nil
	}
	astutil.AddNamedImport(fset, f, "types", fmt.Sprintf("%s/internal/types/%s", ja.Module, file.Package))
	return nil
}

// changeLogicTypes just change logic file logic function params and resp, but not body and others code
func (ja *JzeroApi) changeLogicTypes(f *ast.File, fset *token.FileSet, file LogicFile) error {
	var (
		methodFunc                string
		requestType, responseType spec.Type
	)

	requestType = file.RequestType
	responseType = file.ResponseType
	methodFunc = util.Title(strings.TrimSuffix(file.Handler, "Handler"))

	ast.Inspect(f, func(node ast.Node) bool {
		if fn, ok := node.(*ast.FuncDecl); ok && fn.Recv != nil {
			if fn.Name.Name == methodFunc {
				if requestType != nil {
					switch requestType.(type) {
					case spec.DefineStruct:
						fn.Type.Params.List = []*ast.Field{
							{
								Names: []*ast.Ident{ast.NewIdent("req")},
								Type:  &ast.StarExpr{X: ast.NewIdent("types." + requestType.Name())},
							},
						}
					}
				} else {
					fn.Type.Params.List = nil
				}

				if responseType != nil {
					switch responseType.(type) {
					case spec.PrimitiveType:
						fn.Type.Results.List = []*ast.Field{
							{
								Names: []*ast.Ident{ast.NewIdent("resp")},
								Type:  ast.NewIdent(responseType.Name()),
							},
							{
								Names: []*ast.Ident{ast.NewIdent("err")},
								Type:  ast.NewIdent("error"),
							},
						}
					case spec.DefineStruct:
						fn.Type.Results.List = []*ast.Field{
							{
								Names: []*ast.Ident{ast.NewIdent("resp")},
								Type:  &ast.StarExpr{X: ast.NewIdent("types." + responseType.Name())},
							},
							{
								Names: []*ast.Ident{ast.NewIdent("err")},
								Type:  ast.NewIdent("error"),
							},
						}
					}
				} else {
					fn.Type.Results.List = []*ast.Field{
						{
							Type: ast.NewIdent("error"),
						},
					}
				}
			}
		}
		return true
	})

	// change handler type struct
	ast.Inspect(f, func(node ast.Node) bool {
		if genDecl, ok := node.(*ast.GenDecl); ok && genDecl.Tok == token.TYPE {
			for _, ss := range genDecl.Specs {
				if typeSpec, ok := ss.(*ast.TypeSpec); ok {
					// Only proceed if the struct name matches our methodFunc
					if strings.ToUpper(typeSpec.Name.Name) != strings.ToUpper(methodFunc) {
						continue
					}
					var (
						structType *ast.StructType
						ok         bool
						names      []string
					)
					if structType, ok = typeSpec.Type.(*ast.StructType); ok {
						for _, field := range structType.Fields.List {
							for _, name := range field.Names {
								names = append(names, name.Name)
							}
						}
					}
					if structType != nil && !lo.Contains(names, "r") {
						newField := &ast.Field{
							Names: []*ast.Ident{ast.NewIdent("r")},
							Type:  &ast.StarExpr{X: ast.NewIdent("http.Request")},
						}
						structType.Fields.List = append(structType.Fields.List, newField)
					}

					if structType != nil && responseType == nil && !lo.Contains(names, "w") {
						newField := &ast.Field{
							Names: []*ast.Ident{ast.NewIdent("w")},
							Type:  ast.NewIdent("http.ResponseWriter"),
						}
						structType.Fields.List = append(structType.Fields.List, newField)
					} else if structType != nil && responseType != nil && lo.Contains(names, "w") {
						for i, v := range structType.Fields.List {
							if len(v.Names) > 0 {
								if v.Names[0].Name == "w" {
									// 删除这个元素
									structType.Fields.List = append(structType.Fields.List[:i], structType.Fields.List[i+1:]...)
								}
							}
						}
					}
				}
			}
		}
		return true
	})

	// change New type struct params
	ast.Inspect(f, func(n ast.Node) bool {
		if fn, ok := n.(*ast.FuncDecl); ok && fn.Name.Name == fmt.Sprintf("New%s", methodFunc) {
			var paramNames []string
			for _, param := range fn.Type.Params.List {
				for _, name := range param.Names {
					paramNames = append(paramNames, name.Name)
				}
			}
			if !lo.Contains(paramNames, "r") {
				fn.Type.Params.List = append(fn.Type.Params.List, &ast.Field{
					Names: []*ast.Ident{ast.NewIdent("r")},
					Type:  &ast.StarExpr{X: ast.NewIdent("http.Request")},
				})
			}

			if responseType == nil && !lo.Contains(paramNames, "w") {
				fn.Type.Params.List = append(fn.Type.Params.List, &ast.Field{
					Names: []*ast.Ident{ast.NewIdent("w")},
					Type:  ast.NewIdent("http.ResponseWriter"),
				})
			} else if responseType != nil && lo.Contains(paramNames, "w") {
				for i, v := range fn.Type.Params.List {
					if len(v.Names) > 0 {
						if v.Names[0].Name == "w" {
							fn.Type.Params.List = append(fn.Type.Params.List[:i], fn.Type.Params.List[i+1:]...)
						}
					}
				}
			}

			for _, body := range fn.Body.List {
				if returnStmt, ok := body.(*ast.ReturnStmt); ok {
					for _, result := range returnStmt.Results {
						if unaryExpr, ok := result.(*ast.UnaryExpr); ok {
							if compositeLit, ok := unaryExpr.X.(*ast.CompositeLit); ok {
								if _, ok = compositeLit.Type.(*ast.Ident); ok {
									hasR := false
									hasW := false

									for _, elt := range compositeLit.Elts {
										if kv, ok := elt.(*ast.KeyValueExpr); ok {
											if key, ok := kv.Key.(*ast.Ident); ok {
												if key.Name == "r" {
													hasR = true
												}
												if key.Name == "w" {
													hasW = true
												}
											}
										}
									}

									if !hasR {
										// Add new field
										newField := &ast.KeyValueExpr{
											Key:   ast.NewIdent("r"),
											Value: ast.NewIdent("r"), // or any default value you want
										}
										compositeLit.Elts = append(compositeLit.Elts, newField)
									}

									if responseType == nil && !hasW {
										// Add new field
										newField := &ast.KeyValueExpr{
											Key:   ast.NewIdent("w"),
											Value: ast.NewIdent("w"), // or any default value you want
										}
										compositeLit.Elts = append(compositeLit.Elts, newField)
									} else if responseType != nil && hasW {
										for i, v := range compositeLit.Elts {
											if kv, ok := v.(*ast.KeyValueExpr); ok {
												if key, ok := kv.Key.(*ast.Ident); ok {
													if key.Name == "w" {
														// 删除这个元素
														compositeLit.Elts = append(compositeLit.Elts[:i], compositeLit.Elts[i+1:]...)
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
		return true
	})

	// check `net/http` import
	astutil.AddImport(fset, f, "net/http")
	return nil
}
