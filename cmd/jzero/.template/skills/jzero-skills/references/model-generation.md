# Model Generation

## Overview

jzero supports multiple ways to generate models from SQL schemas. The generated models provide comprehensive CRUD methods with type-safe field constants and caching support.

## ⚠️ Critical Import Rule

**‼️ ALL `internal/model/xx` imports MUST use alias `xxmodel`**

### ❌ WRONG - Direct import without alias
```go
import "github.com/yourproject/internal/model/users"

conditions := condition.New(
    condition.Condition{
        Field: users.Id,  // ❌ WRONG
        Operator: condition.Equal,
        Value: req.Id,
    },
)
```

### ✅ CORRECT - Import with alias
```go
import usersmodel "github.com/yourproject/internal/model/users"

conditions := condition.New(
    condition.Condition{
        Field: usersmodel.Id,  // ✅ CORRECT
        Operator: condition.Equal,
        Value: req.Id,
    },
)
```

**This applies to ALL model imports:** `usersmodel`, `ordersmodel`, `productmodel`, etc.

---

## Method 1: From Local SQL Files (Recommended)

Place SQL DDL files in `desc/sql/` directory:

```bash
desc/sql/
   ├── users.sql
   ├── orders.sql
   └── products.sql
```

Run generation:

```bash
# Generate all models
jzero gen

# Or generate only specified file
jzero gen --desc desc/sql/users.sql
```

## Method 2: From Remote Datasource

Configure in `.jzero.yaml`:

```yaml
gen:
  model-driver: mysql  # or pgx for postgres
  model-cache: true    # enable cache
  model-cache-table:
    - users            # cache specific tables
  # Use remote datasource
  model-datasource: true
  model-datasource-url: "root:123456@tcp(127.0.0.1:3306)/mydb"
  model-datasource-table:
    - users
    - orders
    - products
```

Run generation:

```bash
jzero gen
```

## Method 3: Multiple Datasources

```yaml
gen:
  model-driver: mysql
  model-datasource: true
  # Multiple datasources with schema.table format
  model-datasource-url:
    - "root:123456@tcp(127.0.0.1:3306)/app_db"
    - "root:123456@tcp(127.0.0.1:3306)/log_db"
  model-datasource-table:
    - app_db.users
    - app_db.orders
    - log_db.operation_logs
```

## Example SQL Schema

```sql
CREATE TABLE `users` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `name` varchar(255) NOT NULL,
  `email` varchar(255) NOT NULL UNIQUE,
  `age` int NOT NULL DEFAULT 0,
  `created_at` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `updated_at` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  KEY `idx_email` (`email`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
```

## Generated Model Structure

jzero automatically generates `internal/model/model.go` that registers all models:

```go
// Code generated by jzero. DO NOT EDIT.
package model

import (
    "github.com/eddieowens/opts"
    "github.com/jzero-io/jzero/core/stores/modelx"
    "github.com/zeromicro/go-zero/core/stores/sqlx"
    "github.com/yourproject/internal/model/users"
    "github.com/yourproject/internal/model/orders"
)

type Model struct {
    Users  users.UsersModel
    Orders orders.OrdersModel
}

func NewModel(conn sqlx.SqlConn, op ...opts.Opt[modelx.ModelOpts]) Model {
    return Model{
        Users:  users.NewUsersModel(conn, op...),
        Orders: orders.NewOrdersModel(conn, op...),
    }
}
```

## Generated Field Constants

jzero automatically generates field constants for each model in `internal/model/<table>/<table>model_gen.go`:

```go
// internal/model/users/usersmodel_gen.go
package users

const (
    Id        condition.Field = "id"
    Name      condition.Field = "name"
    Email     condition.Field = "email"
    Age       condition.Field = "age"
    Phone     condition.Field = "phone"
    Status    condition.Field = "status"
    CreatedAt condition.Field = "created_at"
    UpdatedAt condition.Field = "updated_at"
)
```

**Always use these constants instead of hardcoded strings:**

```go
import usersmodel "github.com/yourproject/internal/model/users"

// ✅ CORRECT - Use generated constants
conditions := condition.New(
    condition.Condition{
        Field:    usersmodel.Id,
        Operator: condition.Equal,
        Value:    req.Id,
    },
)

// ❌ WRONG - Don't use hardcoded strings
conditions := condition.New(
    condition.Condition{
        Field:    "id",  // Hardcoded string
        Operator: condition.Equal,
        Value:    req.Id,
    },
)
```

**Benefits of using constants:**
- Type-safe - IDE can validate and autocomplete
- Refactor-friendly - Rename-safe across the codebase
- Prevents typos - Catch errors at compile time
- Consistent naming - Follows jzero conventions

## Generated Model Methods

jzero generates these methods by default for each model:

### Insert Methods

| Method | Description | When to Use |
|--------|-------------|-------------|
| `Insert(ctx, session, data)` | Insert single row | Insert without getting ID |
| `InsertV2(ctx, session, data)` | Insert + return ID | Need auto-increment ID |
| `BulkInsert(ctx, session, data)` | Batch insert | Insert multiple rows efficiently |

### Query Methods

| Method | Description | When to Use |
|--------|-------------|-------------|
| `FindOne(ctx, session, id)` | Find by primary key | Query single record by ID |
| `FindByCondition(ctx, session, ...)` | Find by conditions | Query with custom conditions |
| `FindOneByCondition(ctx, session, ...)` | Find one by conditions | Query single record with conditions |
| `FindFieldsByCondition(ctx, session, ...)` | Find specific fields | Query selected columns only |
| `FindOneFieldsByCondition(ctx, session, ...)` | Find one with fields | Single record + selected columns |
| `CountByCondition(ctx, session, ...)` | Count by conditions | Get total count |
| `PageByCondition(ctx, session, ...)` | Paginated query | Pagination with conditions |

### Update Methods

| Method | Description | When to Use |
|--------|-------------|-------------|
| `Update(ctx, session, data)` | Update by primary key | Update known record |
| `UpdateFieldsByCondition(ctx, session, data, ...)` | Update fields by conditions | Conditional update |

### Delete Methods

| Method | Description | When to Use |
|--------|-------------|-------------|
| `Delete(ctx, session, id)` | Delete by primary key | Delete known record |
| `DeleteByCondition(ctx, session, ...)` | Delete by conditions | Conditional delete |

### Utility Methods

| Method | Description | When to Use |
|--------|-------------|-------------|
| `WithTable(func(table) string).Method(...)` | Specify table name | Table sharding |

## Related Documentation

- [Database Connection](./database-connection.md) - Setting up database connections
- [Condition Builder](./condition-builder.md) - Building query conditions
- [CRUD Operations](./crud-operations.md) - Using generated methods
- [Best Practices](./best-practices.md) - Database usage guidelines
