# Model Generation

## Overview

jzero supports multiple ways to generate models from SQL schemas. The generated models provide comprehensive CRUD methods with type-safe field constants and caching support.

## ⚠️ Important: Migration Requirements

**When modifying database schemas, you MUST create migration files** in `desc/sql_migration/` to track changes and enable rollbacks.

- **Required**: Create migration files (xx.up.sql and xx.down.sql) for any schema changes
- **Development**: Use `jzero migrate` commands with `.jzero.yaml`
- **Production**: Use code-based migration in `cmd/server.go` - automatic on startup

See [SQL Migration Guide](./sql-migration.md) for complete migration workflow.

## Method 1: From Local SQL Files (Recommended)

Place SQL DDL files in `desc/sql/` directory:

```bash
desc/sql/
   ├── users.sql
   ├── orders.sql
   └── products.sql
```

### Local SQL Mode Workflow

1. **Place SQL files** in `desc/sql/` directory
2. **Create migration files** in `desc/sql_migration/` for schema changes (xx.up.sql and xx.down.sql)
3. **Generate models**: Run `jzero gen --desc desc/sql/table.sql`
4. **Apply migrations**:
   - Development: Use `jzero migrate up` with `.jzero.yaml`
   - Production: Automatic via code in `cmd/server.go`

### Best Practices for Local SQL Mode

- **Keep DDL files organized** - One table per file
- **Version control schema** - SQL files track schema evolution
- **Create migrations for changes** - Every schema modification needs xx.up.sql and xx.down.sql
- **Use `.jzero.yaml` for generation config** - Centralize settings

Run generation:

```bash
# Generate all models
jzero gen

# Or generate only specified file
jzero gen --desc desc/sql/users.sql
```

## Method 2: From Remote Datasource

Configure in `.jzero.yaml`:

```yaml
gen:
  model-driver: mysql  # or pgx for postgres
  model-cache: true    # enable cache
  model-cache-table:
    - users            # cache specific tables
  # Use remote datasource
  model-datasource: true
  model-datasource-url: "root:123456@tcp(127.0.0.1:3306)/mydb"
  model-datasource-table:
    - users
    - orders
    - products
```

### Remote Datasource Mode Workflow

1. **Create migration files** directly in `desc/sql_migration/` (no need for `desc/sql/*.sql` files)
2. **Apply migrations to database**:
   - Development: Use `jzero migrate up` with `.jzero.yaml`
   - Production: Automatic via code in `cmd/server.go`
3. **Generate models from database**: Run `jzero gen`
4. **Database is source of truth** - Schema comes from actual database structure

### Best Practices for Remote Datasource Mode

- **Create migrations directly** - No `desc/sql/*.sql` files needed
- **Apply migrations first** - Ensure database is up-to-date before generating models
- **Regenerate after schema changes** - Models reflect latest database structure
- **Use `.jzero.yaml` for datasource config** - Centralize connection settings
- **Database-first approach** - Suitable for existing databases or database-first development

Run generation:

```bash
# Generate from configured datasource
jzero gen
```

## Method 3: Multiple Datasources

```yaml
gen:
  model-driver: mysql
  model-datasource: true
  # Multiple datasources with schema.table format
  model-datasource-url:
    - "root:123456@tcp(127.0.0.1:3306)/app_db"
    - "root:123456@tcp(127.0.0.1:3306)/log_db"
  model-datasource-table:
    - app_db.users
    - app_db.orders
    - log_db.operation_logs
```

## Example SQL Schema

```sql
CREATE TABLE `users` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `name` varchar(255) NOT NULL,
  `email` varchar(255) NOT NULL UNIQUE,
  `age` int NOT NULL DEFAULT 0,
  `created_at` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `updated_at` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  KEY `idx_email` (`email`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
```

## Generated Model Structure

jzero automatically generates `internal/model/model.go` that registers all models:

```go
// Code generated by jzero. DO NOT EDIT.
package model

import (
    "github.com/eddieowens/opts"
    "github.com/jzero-io/jzero/core/stores/modelx"
    "github.com/zeromicro/go-zero/core/stores/sqlx"
    "github.com/yourproject/internal/model/users"
    "github.com/yourproject/internal/model/orders"
)

type Model struct {
    Users  users.UsersModel
    Orders orders.OrdersModel
}

func NewModel(conn sqlx.SqlConn, op ...opts.Opt[modelx.ModelOpts]) Model {
    return Model{
        Users:  users.NewUsersModel(conn, op...),
        Orders: orders.NewOrdersModel(conn, op...),
    }
}
```

## Generated Model Methods

jzero generates these methods by default for each model:

### Insert Methods

| Method | Description | When to Use |
|--------|-------------|-------------|
| `Insert(ctx, session, data)` | Insert single row | Insert without getting ID |
| `InsertV2(ctx, session, data)` | Insert + return ID | Need auto-increment ID |
| `BulkInsert(ctx, session, data)` | Batch insert | Insert multiple rows efficiently |

### Query Methods

| Method | Description | When to Use |
|--------|-------------|-------------|
| `FindOne(ctx, session, id)` | Find by primary key | Query single record by ID |
| `FindByCondition(ctx, session, ...)` | Find by conditions | Query with custom conditions |
| `FindOneByCondition(ctx, session, ...)` | Find one by conditions | Query single record with conditions |
| `FindFieldsByCondition(ctx, session, ...)` | Find specific fields | Query selected columns only |
| `FindOneFieldsByCondition(ctx, session, ...)` | Find one with fields | Single record + selected columns |
| `CountByCondition(ctx, session, ...)` | Count by conditions | Get total count |
| `PageByCondition(ctx, session, ...)` | Paginated query | Pagination with conditions |

### Update Methods

| Method | Description | When to Use |
|--------|-------------|-------------|
| `Update(ctx, session, data)` | Update by primary key | Update known record |
| `UpdateFieldsByCondition(ctx, session, data, ...)` | Update fields by conditions | Conditional update |

### Delete Methods

| Method | Description | When to Use |
|--------|-------------|-------------|
| `Delete(ctx, session, id)` | Delete by primary key | Delete known record |
| `DeleteByCondition(ctx, session, ...)` | Delete by conditions | Conditional delete |

### Utility Methods

| Method | Description | When to Use |
|--------|-------------|-------------|
| `WithTable(func(table) string).Method(...)` | Specify table name | Table sharding |

## Configuration Best Practices

### Both Modes

- **Use `.jzero.yaml` for generation configuration** - Centralize your generation settings
- **Enable caching for read-heavy models** - Use `model-cache: true` and `model-cache-table` for appropriate tables

### Choosing the Right Mode

| Factor | Local SQL Mode | Remote Datasource Mode |
|--------|---------------|---------------------|
| **Schema source** | `desc/sql/*.sql` files | Database |
| **Migration files** | `desc/sql_migration/` | `desc/sql_migration/` |
| **Model generation** | `jzero gen --desc desc/sql/x.sql` | `jzero gen` |
| **Best for** | New projects, code-first | Existing databases, database-first |
| **Team collaboration** | Code reviews on schema files | Code reviews on migration files |

### When to Use Each Mode

**Use Local SQL Mode when**:
- Starting a new project
- Want version-controlled schema definitions
- Prefer code-first development
- Need clear documentation of database structure
- Team reviews schema changes in code

**Use Remote Datasource Mode when**:
- Working with existing databases
- Prefer database-first development
- Multiple services share same database
- Don't need separate SQL files
- Want simpler file structure

## Related Documentation

- [Database Connection](./database-connection.md) - Setting up database connections
- [SQL Migration Guide](./sql-migration.md) - Managing schema changes with migrations
- [CRUD Operations](./crud-operations.md) - Using generated methods
- [Best Practices](./best-practices.md) - Database operation guidelines and critical rules
