// Code generated by goctl. DO NOT EDIT.
// goctl {{.version}}

package model

import (
	"context"
	"time"

	"github.com/eddieowens/opts"
	"github.com/jzero-io/jzero/core/stores/monx"
	"github.com/zeromicro/go-zero/core/stores/mon"
	"github.com/zeromicro/go-zero/core/stores/monc"
	"go.mongodb.org/mongo-driver/v2/bson"
	"go.mongodb.org/mongo-driver/v2/mongo"
	"go.mongodb.org/mongo-driver/v2/mongo/options"
)

{{if .Cache}}var prefix{{.Type}}CacheKey = "{{if .Prefix}}{{.Prefix}}:{{end}}cache:{{.lowerType}}:"{{end}}

type {{.lowerType}}Model interface{
    Insert(ctx context.Context,data *{{.Type}}, opts ...options.Lister[options.InsertOneOptions]) error
    FindOne(ctx context.Context,id string) (*{{.Type}}, error)
    Update(ctx context.Context,data *{{.Type}}) (*mongo.UpdateResult, error)
    Delete(ctx context.Context,id string) (int64, error)

    // custom interface generated by jzero
    BulkInsert(ctx context.Context, data []*{{.Type}}, opts ...options.Lister[options.InsertManyOptions]) error
    FindOneByCondition(ctx context.Context, condition any, opts ...options.Lister[options.FindOneOptions]) (*{{.Type}}, error)
    FindByCondition(ctx context.Context, condition any, opts ...options.Lister[options.FindOptions]) ([]*{{.Type}}, error)
    DeleteByCondition(ctx context.Context, condition any, opts ...options.Lister[options.DeleteManyOptions]) (int64, error)
}

type default{{.Type}}Model struct {
    conn *mon.Model
    cachedConn *monc.Model
}

func newDefault{{.Type}}Model(url, db string, op ...opts.Opt[monx.MonOpts]) *default{{.Type}}Model {
    o := opts.DefaultApply(op...)

	var (
		cachedConn *monc.Model
	)

	conn := mon.MustNewModel(url, db, {{.Type}}CollectionName)
	if len(o.CacheConf) > 0 {
		cachedConn = monc.MustNewModel(url,db, {{.Type}}CollectionName, o.CacheConf, o.CacheOpts...)
	}

	return &default{{.Type}}Model{conn: conn, cachedConn: cachedConn}
}


func (m *default{{.Type}}Model) Insert(ctx context.Context, data *{{.Type}}, opts ...options.Lister[options.InsertOneOptions]) error {
    if data.ID.IsZero() {
        data.ID = bson.NewObjectID()
        data.CreateAt = time.Now()
        data.UpdateAt = time.Now()
    }

    {{if .Cache}}key := prefix{{.Type}}CacheKey + data.ID.Hex()
    _, err := m.cachedConn.InsertOne(ctx, {{if .Cache}}key, {{end}} data, opts...) {{else}}_, err := m.conn.InsertOne(ctx, data, opts...) {{end}}
    return err
}

func (m *default{{.Type}}Model) BulkInsert(ctx context.Context, data []*{{.Type}}, opts ...options.Lister[options.InsertManyOptions]) error {
    for _, d := range data {
        if d.ID.IsZero() {
            d.ID = bson.NewObjectID()
            d.CreateAt = time.Now()
            d.UpdateAt = time.Now()
        }
    }

    var documents []any
    for _, d := range data {
        documents = append(documents, d)
    }
    {{if .Cache}}_, err := m.cachedConn.InsertMany(ctx, {{if .Cache}}key, {{end}} documents, opts...) {{else}}_, err := m.conn.InsertMany(ctx, documents, opts...) {{end}}
    return err
}

func (m *default{{.Type}}Model) FindOne(ctx context.Context, id string) (*{{.Type}}, error) {
    oid, err := bson.ObjectIDFromHex(id)
    if err != nil {
        return nil, ErrInvalidObjectId
    }

    var data {{.Type}}
    {{if .Cache}}key := prefix{{.Type}}CacheKey + id
    err = m.cachedConn.FindOne(ctx, {{if .Cache}}key, {{end}}&data, bson.M{"_id": oid}) {{else}}err = m.conn.FindOne(ctx, &data, bson.M{"_id": oid}) {{end}}
    switch err {
    case nil:
        return &data, nil
    case {{if .Cache}}monc{{else}}mon{{end}}.ErrNotFound:
        return nil, ErrNotFound
    default:
        return nil, err
    }
}

func (m *default{{.Type}}Model) FindOneByCondition(ctx context.Context, condition any, opts ...options.Lister[options.FindOneOptions]) (*{{.Type}}, error) {
    var data {{.Type}}
    {{if .Cache}}err := m.cachedConn.FindOne(ctx, {{if .Cache}}key, {{end}}&data, condition, opts...) {{else}}err := m.conn.FindOne(ctx, &data, condition, opts...) {{end}}
    switch err {
    case nil:
        return &data, nil
    case {{if .Cache}}monc{{else}}mon{{end}}.ErrNotFound:
        return nil, ErrNotFound
    default:
        return nil, err
    }
}

func (m *default{{.Type}}Model) FindByCondition(ctx context.Context, condition any, opts ...options.Lister[options.FindOptions]) ([]*{{.Type}}, error) {
    var data []*{{.Type}}
    {{if .Cache}}err := m.cachedConn.Find(ctx, {{if .Cache}}key, {{end}}&data, condition, opts...) {{else}}err := m.conn.Find(ctx, &data, condition, opts...) {{end}}
    switch err {
    case nil:
        return data, nil
    case {{if .Cache}}monc{{else}}mon{{end}}.ErrNotFound:
        return nil, ErrNotFound
    default:
        return nil, err
    }
}

func (m *default{{.Type}}Model) Update(ctx context.Context, data *{{.Type}}) (*mongo.UpdateResult, error) {
    data.UpdateAt = time.Now()
    {{if .Cache}}key := prefix{{.Type}}CacheKey + data.ID.Hex()
    res, err := m.cachedConn.UpdateOne(ctx, {{if .Cache}}key, {{end}}bson.M{"_id": data.ID}, bson.M{"$set": data}) {{else}}res, err := m.conn.UpdateOne(ctx, bson.M{"_id": data.ID}, bson.M{"$set": data}) {{end}}
    return res, err
}

func (m *default{{.Type}}Model) Delete(ctx context.Context, id string) (int64, error) {
    oid, err := bson.ObjectIDFromHex(id)
    if err != nil {
        return 0, ErrInvalidObjectId
    }
	{{if .Cache}}key := prefix{{.Type}}CacheKey +id
    res, err := m.cachedConn.DeleteOne(ctx, {{if .Cache}}key, {{end}}bson.M{"_id": oid}) {{else}}res, err := m.conn.DeleteOne(ctx, bson.M{"_id": oid}) {{end}}
	return res, err
}

func (m *default{{.Type}}Model) DeleteByCondition(ctx context.Context, condition any, opts ...options.Lister[options.DeleteManyOptions]) (int64, error) {
    {{if .Cache}}res, err := m.cachedConn.DeleteMany(ctx, {{if .Cache}}key, {{end}}condition, opts...) {{else}}res, err := m.conn.DeleteMany(ctx, condition, opts...) {{end}}
	return res, err
}
