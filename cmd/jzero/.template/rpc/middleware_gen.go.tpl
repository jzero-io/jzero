// Code generated by jzero. DO NOT EDIT.

package middleware

import (
	"fmt"
	"context"
    "regexp"

	"github.com/zeromicro/go-zero/gateway"
	"github.com/zeromicro/go-zero/zrpc"
	"google.golang.org/grpc"
)

var (
	_ = fmt.Sprintf("middleware_gen.go")
	_ = context.Background()
    _ = grpc.SupportPackageIsVersion7
)

// RegisterGen register zrpc middleware
func RegisterGen(zrpc *zrpc.RpcServer, gw *gateway.Server) {
	{{- range $v := .HttpMiddlewares}}
	gw.Use({{$v.Name | FirstUpper}}Middleware)
	{{- end}}

	{{- range $v := .ZrpcMiddlewares}}
	zrpc.AddUnaryInterceptors({{$v.Name | FirstUpper}}Middleware)
	zrpc.AddStreamInterceptors({{$v.Name | FirstUpper}}StreamMiddleware)
	{{- end}}
}

// Define and compile routes
var routesMap map[string][]*regexp.Regexp

// loadRoute compiles and stores a route pattern.
func loadRoutes(middleware string, patterns ...string) {
	if routesMap == nil {
		routesMap = make(map[string][]*regexp.Regexp)
	}

	re := regexp.MustCompile(`\{[^}]+\}`)
	var routes []*regexp.Regexp
	for _, pattern := range patterns {
		pattern = re.ReplaceAllString(pattern, "([^/]+)")
		compiledPattern := "^" + pattern + "$"
		routes = append(routes, regexp.MustCompile(compiledPattern))
	}
	routesMap[middleware] = routes
}

// MatchRoute checks if a route matches any compiled route.
func MatchRoute(middleware, route string) bool {
	if routesReg, ok := routesMap[middleware]; ok {
		for _, rr := range routesReg {
			if rr.MatchString(route) {
				return true
			}
		}
	}
	return false
}

func init() {
    {{range $v := .HttpMiddlewares}}
        loadRoutes("{{$v.Name}}",
	    {{range $vv := $v.Routes}}"{{$vv}}",
	    {{end}})
    {{end}}

    {{range $v := .ZrpcMiddlewares}}
        loadRoutes("{{$v.Name}}",
	    {{range $vv := $v.Routes}}"{{$vv}}",
	    {{end}})
    {{end}}
}